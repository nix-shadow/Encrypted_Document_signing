# Encrypted Document Signing Platform - Development Prompt

## Project Request

Create a complete, production-ready **Encrypted Document Signing Platform** with the following specifications:

---

## Core Requirements

### 1. Technology Stack
- **Backend**: Python with Flask or FastAPI
- **Frontend**: Modern HTML5, CSS3, JavaScript (vanilla or React)
- **Database**: PostgreSQL
- **Cryptography**: PyCryptodome or cryptography library
- **Security**: HTTPS, secure session management, password hashing (bcrypt/argon2)

### 2. Cryptographic Features

**Encryption Layer:**
- Implement AES-256 encryption in CBC or GCM mode for document confidentiality
- Generate unique random AES keys for each document
- Use RSA-2048 or RSA-4096 for asymmetric key operations
- Implement secure key exchange using recipient's RSA public key

**Digital Signature:**
- Create SHA-256 hash of documents before signing
- Sign hash using sender's RSA private key
- Verify signatures using sender's public key during document access
- Detect any unauthorized modifications through signature validation

### 3. User Authentication & Authorization
- Secure user registration with email validation
- Password hashing using bcrypt or Argon2
- Session-based authentication with secure cookies
- RSA key pair generation during user registration
- Encrypted storage of user private keys (encrypted with user password)

### 4. Core Functionalities

**User Management:**
- Register new users with automatic RSA key pair generation
- Secure login with session management
- User profile showing public key
- Password change functionality

**Document Operations:**
- Upload documents (PDF, DOCX, TXT, images)
- Automatic encryption with unique AES key
- Digital signature generation
- List user's uploaded documents
- Download and decrypt documents (with signature verification)
- Delete documents

**Document Sharing:**
- Share encrypted documents with other registered users
- Re-encrypt AES key with recipient's public key
- Recipient can decrypt and verify document authenticity
- Revoke document access

**Security Features:**
- Signature verification before displaying documents
- Tamper detection alerts
- Audit logging of all critical operations
- Session timeout and CSRF protection

### 5. Database Schema

Include tables for:
- **users**: user credentials, RSA keys, metadata
- **documents**: encrypted content, signatures, keys, hashes
- **document_shares**: sharing relationships with re-encrypted keys
- **audit_log**: security and access tracking

### 6. User Interface

**Pages Required:**
- Landing/Home page with project overview
- User Registration page
- Login page
- Dashboard showing user's documents
- Document upload interface
- Document viewer with verification status
- Document sharing interface
- User profile page

**UI/UX Requirements:**
- Clean, modern, professional design
- Visual indicators for signature verification (âœ“ verified / âœ— tampered)
- Progress indicators for encryption/decryption operations
- Responsive design for mobile and desktop
- Clear error messages and success notifications

### 7. Security Best Practices

- Never store unencrypted documents or AES keys
- Use environment variables for sensitive configuration
- Implement rate limiting on login attempts
- Sanitize all user inputs to prevent injection attacks
- Use HTTPS in production
- Implement secure file upload validation
- Clear sensitive data from memory after use
- Use cryptographically secure random number generators

### 8. Code Organization

```

## ðŸ“¦ Project File Structure
```
encrypted-doc-platform/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py              # App factory
â”‚   â”œâ”€â”€ config.py                # Configuration
â”‚   â”‚
â”‚   â”œâ”€â”€ models/                  # Data models
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user.py
â”‚   â”‚   â”œâ”€â”€ document.py
â”‚   â”‚   â”œâ”€â”€ share.py
â”‚   â”‚   â””â”€â”€ audit_log.py
â”‚   â”‚
â”‚   â”œâ”€â”€ routes/                  # Route handlers
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth.py              # Authentication routes
â”‚   â”‚   â”œâ”€â”€ documents.py         # Document operations
â”‚   â”‚   â”œâ”€â”€ shares.py            # Sharing operations
â”‚   â”‚   â””â”€â”€ users.py             # User management
â”‚   â”‚
â”‚   â”œâ”€â”€ services/                # Business logic
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user_service.py
â”‚   â”‚   â”œâ”€â”€ document_service.py
â”‚   â”‚   â”œâ”€â”€ share_service.py
â”‚   â”‚   â””â”€â”€ audit_service.py
â”‚   â”‚
â”‚   â”œâ”€â”€ crypto/                  # Cryptography module
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ aes_encryption.py    # AES operations
â”‚   â”‚   â”œâ”€â”€ rsa_operations.py    # RSA key gen, encryption
â”‚   â”‚   â”œâ”€â”€ digital_signature.py # Signing and verification
â”‚   â”‚   â”œâ”€â”€ hash_utils.py        # Hashing functions
â”‚   â”‚   â””â”€â”€ key_manager.py       # Key storage/retrieval
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/                   # Utilities
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ validators.py        # Input validation
â”‚   â”‚   â”œâ”€â”€ decorators.py        # Auth decorators
â”‚   â”‚   â””â”€â”€ helpers.py           # Helper functions
â”‚   â”‚
â”‚   â”œâ”€â”€ templates/               # HTML templates
â”‚   â”‚   â”œâ”€â”€ base.html
â”‚   â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”‚   â”œâ”€â”€ login.html
â”‚   â”‚   â”‚   â””â”€â”€ register.html
â”‚   â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”‚   â”œâ”€â”€ upload.html
â”‚   â”‚   â”‚   â””â”€â”€ documents.html
â”‚   â”‚   â””â”€â”€ shared/
â”‚   â”‚       â””â”€â”€ documents.html
â”‚   â”‚
â”‚   â””â”€â”€ static/                  # Static files
â”‚       â”œâ”€â”€ css/
â”‚       â”‚   â””â”€â”€ styles.css
â”‚       â”œâ”€â”€ js/
â”‚       â”‚   â””â”€â”€ main.js
â”‚       â””â”€â”€ images/
â”‚
â”œâ”€â”€ migrations/                  # Database migrations
â”‚   â””â”€â”€ init_db.sql
â”‚
â”œâ”€â”€ tests/                       # Unit tests
â”‚   â”œâ”€â”€ test_crypto.py
â”‚   â”œâ”€â”€ test_auth.py
â”‚   â””â”€â”€ test_documents.py
â”‚
â”œâ”€â”€ .env.example                 # Environment template
â”œâ”€â”€ .gitignore
â”œâ”€â”€ requirements.txt             # Dependencies
â”œâ”€â”€ run.py                       # Application entry point
â””â”€â”€ README.md                    # Documentation
```

### 9. Deliverables

1. **Complete source code** with all features implemented
2. **Database schema** with initialization scripts
3. **Requirements.txt** with all dependencies
4. **README.md** with:
   - Setup instructions
   - How to run the application
   - Architecture overview
   - Security considerations
   - API documentation (if applicable)
5. **Environment configuration template** (.env.example)
6. **Sample demonstration** workflow

### 10. Bonus Features (Optional)

- Document version history
- Bulk document encryption
- Document expiration dates
- Two-factor authentication
- Email notifications for document shares
- API endpoints for programmatic access
- Docker containerization
- Document preview without full download
- Search and filter documents
- Export encryption keys (securely)

---

## Implementation Notes

- Ensure all cryptographic operations use industry-standard libraries
- Private keys should NEVER be stored unencrypted
- Document content should NEVER touch disk unencrypted
- Implement comprehensive error handling
- Add logging for debugging (without logging sensitive data)
- Write clear comments explaining cryptographic operations
- Include sample documents for testing

## Success Criteria

The system should successfully:
1. âœ… Register users and generate RSA key pairs
2. âœ… Encrypt documents with AES and sign with RSA
3. âœ… Store encrypted documents securely in database
4. âœ… Share documents with key re-encryption
5. âœ… Decrypt and verify signatures correctly
6. âœ… Detect tampered documents
7. âœ… Prevent unauthorized access
8. âœ… Log all security-relevant events

---

## Getting Started

Build this as a fully functional web application that demonstrates real-world cryptographic security. Focus on correctness of cryptographic implementations and user experience. The system should be suitable for demonstration in academic or professional settings.

Create artifacts for each major component as needed, and ensure the complete system is ready to deploy and demonstrate.